---
phase: 02-core-reliability-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Src/Bof.c
autonomous: true
requirements: [RELI-01]
must_haves:
  truths:
    - Repeated failure paths in SpawnAndRun do not leak owned handles or heap allocations.
    - Failure exits preserve original NTSTATUS while still finalizing owned resources.
    - Cleanup behavior is deterministic and idempotent for partial initialization states.
  artifacts:
    - Src/Bof.c
  key_links:
    - SpawnAndRun ownership points route all failures through centralized cleanup before return.
---

<objective>
Refactor `SpawnAndRun` to a centralized cleanup/finalization model for reliability.

Purpose: satisfy RELI-01 by eliminating fragile early-return resource leaks.
Output: single-exit cleanup flow that releases all owned process/thread/heap resources safely.
</objective>

<execution_context>
@/Users/maleick/.codex/get-shit-done/workflows/execute-plan.md
@/Users/maleick/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/02-core-reliability-hardening/02-CONTEXT.md
@.planning/phases/02-core-reliability-hardening/02-RESEARCH.md
@Src/Bof.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert SpawnAndRun to single-exit failure flow</name>
  <files>Src/Bof.c</files>
  <action>Refactor `SpawnAndRun` so error branches set `Status` and branch to a shared cleanup label instead of returning immediately. Keep success path explicit and preserve the original failing NTSTATUS for return.</action>
  <verify><automated>rg -n 'SpawnAndRun|goto cleanup|cleanup:|return Status;' Src/Bof.c</automated></verify>
  <done>All non-success exits in SpawnAndRun route through one finalization path before returning.</done>
</task>

<task type="auto">
  <name>Task 2: Finalize all owned resources in deterministic order</name>
  <files>Src/Bof.c</files>
  <action>Implement null-safe cleanup for all owned resources initialized in `SpawnAndRun` (parent/process/thread handles, attribute-list heap allocation, process parameters). Ensure cleanup can run safely from partially initialized states without double-close/double-free behavior.</action>
  <verify><automated>rg -n 'NtClose|RtlFreeHeap|RtlDestroyProcessParameters|hParentProcess|hProcess|hThread|AttributeList|ProcessParameters' Src/Bof.c</automated></verify>
  <done>Resource ownership in SpawnAndRun is explicitly finalized in one cleanup block with idempotent guards.</done>
</task>

<task type="auto">
  <name>Task 3: Add focused self-check comments for ownership boundaries</name>
  <files>Src/Bof.c</files>
  <action>Add concise comments near cleanup ownership declarations documenting which code path owns each resource and where release happens. Keep comments short and strictly reliability-oriented.</action>
  <verify><automated>rg -n 'cleanup ownership|owned by SpawnAndRun|released in cleanup' Src/Bof.c</automated></verify>
  <done>Future modifications can quickly audit ownership assumptions and avoid leak regressions.</done>
</task>

</tasks>

<verification>
- RELI-01 is represented in frontmatter and covered by task outcomes.
- SpawnAndRun failure paths no longer bypass cleanup.
- Cleanup order and guards support repeated failure runs.
</verification>

<success_criteria>
- [ ] RELI-01 implemented completely.
- [ ] Failure paths do not leak owned resources.
- [ ] Return status remains the original failing NTSTATUS.
</success_criteria>

<output>
After completion, create .planning/phases/02-core-reliability-hardening/02-01-SUMMARY.md.
</output>
